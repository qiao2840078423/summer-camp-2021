# ES6

[TOC]

### ECMAScript 6简介

- ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现

------

### let和const命令

#### let命令

- JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量`i`时，就在上一轮循环的基础上进行计算

- `for`循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
- 不存在变量提升
- 在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”
- `let`不允许在相同作用域内，重复声明同一个变量
- 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要

#### 块级作用域

- ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域

#### const命令

- 声明一个只读的常量

- `const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效

- `const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用

- `const`声明的常量，也与`let`一样不可重复声明

- `const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动

- `var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性

  ------

### 变量的解构赋值

#### 数组的解构赋值

- 如果解构不成功，变量的值就等于`undefined`
- ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效
- 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值

#### 对象的解构赋值

- 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量

![image-20230329113804479](E:\Github\summer-camp-2021\Joe\notes\images\image-20230329113804479.png)

![image-20230329113914344](E:\Github\summer-camp-2021\Joe\notes\images\image-20230329113914344.png)

![image-20230329113952206](E:\Github\summer-camp-2021\Joe\notes\images\image-20230329113952206.png)

-  JavaScript 引擎会将`{x}`理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块

#### 字符串的解构赋值

![image-20230403171847148](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403171847148.png)

#### 圆括号问题

- 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号

  ------

### 函数

#### 函数参数的默认值

- 参数变量是默认声明的，所以不能用`let`或`const`再次声明
- 使用参数默认值时，函数不能有同名参数

![image-20230403200139978](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403200139978.png)

- 参数默认值是惰性求值的
- 参数默认值可以与解构赋值的默认值，结合起来使用

![image-20230403200448042](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403200448042.png)

- 如果非尾部的参数设置默认值，实际上这个参数是没法省略的

![image-20230403201328856](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403201328856.png)

- 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入`undefined`
- 如果传入`undefined`，将触发该参数等于默认值，`null`则没有这个效果
- 指定了默认值以后，函数的`length`属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，`length`属性将失真
- 如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了
- 代码中，参数`x = x`形成一个单独作用域。实际执行的是`let x = x`，由于暂时性死区的原因，这行代码会报错”x 未定义“

![image-20230403201749360](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403201749360.png)

#### rest参数

![image-20230403202711740](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403202711740.png)

- 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错

#### 严格模式

- 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错
- 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行

#### name属性

- 函数的`name`属性，返回该函数的函数名
- 如果将一个匿名函数赋值给一个变量，ES5 的`name`属性，会返回空字符串，而 ES6 的`name`属性会返回实际的函数名

![image-20230403203316288](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403203316288.png)

- 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的`name`属性都返回这个具名函数原本的名字

![image-20230403203402338](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403203402338.png)

- `Function`构造函数返回的函数实例，`name`属性的值为`anonymous`

![image-20230403203522897](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403203522897.png)

- `bind`返回的函数，`name`属性值会加上`bound`前缀

![image-20230403203549243](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403203549243.png)

#### 箭头函数

- 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分
- 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回
- 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错

![image-20230403210954144](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403210954144.png)

- **使用注意点**
- （1）函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象
- （2）不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误
- （3）不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替
- （4）不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数
- 上面四点中，第一点尤其值得注意。`this`对象的指向是可变的，但是在箭头函数中，它是固定的
- 箭头函数让this绑定定义时所在的作用域，而不是指向运行时所在的作用域

![image-20230403211410919](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403211410919.png)

- 上面代码中，`Timer`函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的`this`绑定定义时所在的作用域（即`Timer`函数），后者的`this`指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，`timer.s1`被更新了 3 次，而`timer.s2`一次都没更新
- 箭头函数可以让`this`指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面

![image-20230403211443966](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403211443966.png)

- 上面代码的`init`方法中，使用了箭头函数，这导致这个箭头函数里面的`this`，总是指向`handler`对象。否则，回调函数运行时，`this.doSomething`这一行会报错，因为此时`this`指向`document`对象
- `this`指向的固定化，并不是因为箭头函数内部有绑定`this`的机制，实际原因是箭头函数根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`。正是因为它没有`this`，所以也就不能用作构造函数
- 除了`this`，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：`arguments`、`super`、`new.target`
- 箭头函数内部的变量`arguments`，其实是函数`foo`的`arguments`变量
- 由于箭头函数没有自己的`this`，所以当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变`this`的指向
- **不适用场合**
- **（1）定义对象的方法，且该方法内部包括`this`**

![image-20230403211644847](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403211644847.png)

- 上面代码中，`cat.jumps()`方法是一个箭头函数，这是错误的。调用`cat.jumps()`时，如果是普通函数，该方法内部的`this`指向`cat`；如果写成上面那样的箭头函数，使得`this`指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致`jumps`箭头函数定义时的作用域就是全局作用域
- **（2）需要动态`this`的时候，也不应使用箭头函数**

![image-20230403211746193](E:\Github\summer-camp-2021\Joe\notes\images\image-20230403211746193.png)

- 上面代码运行时，点击按钮会报错，因为`button`的监听函数是一个箭头函数，导致里面的`this`就是全局对象。如果改成普通函数，`this`就会动态指向被点击的按钮对象
- 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性