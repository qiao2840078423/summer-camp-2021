# 算法基础

## 一、数组和字符串

### 1. reduce方法

[Array.reduce()方法详解及高级技巧](https://juejin.cn/post/6934513005401292808)

##### reduce的用法

- 数组求和
- 数组求积
- 计算数组中每个元素出现的次数
- 数组去重
- 将二维数组转化成一维数组
- 对象里的属性求和

### 2. 二分法

[基础算法一：二分法，你思考过这些问题吗？](https://zhuanlan.zhihu.com/p/308605122)

[如何用一文搞懂二分法查找？](https://www.zhihu.com/question/484150493)

### 3. 二维数组

#### 3.1 旋转矩阵

https://zhuanlan.zhihu.com/p/106971744

- 公式法
- 二次置换法(先倒序行再倒置)
- 边整体旋转法
- 边元素依次旋转法

### 4. split方法

按照一个或多个空格切割字符串：

```javascript
str.trim().split(/\s+/)
```

### 5. 是否改变原数组的方法

https://juejin.cn/post/7107415332666474504

改变：

- push
- unshift
- pop
- shift
- sort
- splice
- reverse

不改变：

- concat
- join
- reduce
- map
- forEach
- filter
- slice
- findIndex

### 6. KMP算法

https://blog.csdn.net/qq_62982856/article/details/128003067

```typescript
function strStr(haystack: string, needle: string): number {
    const hLen = haystack.length
    const nLen = needle.length
    // 1. 求next数组
    const next = new Array(nLen).fill(0)
    next[0] = 0
    let len = 0
    let i = 1
    while(i < nLen) {
        if (needle[i] === needle[len]) {
            next[i] = ++len
            i ++
        }
        else {
            if (len === 0) {
                next[i] = 0
                i ++
            }
            else {
                len = next[len - 1]
            }
        }
    }

    // 2. KMP算法
    let [p, q] = [0, 0]
    while (p < hLen && q < nLen) {
        if (haystack[p] === needle[q]) {
            p ++
            q ++
        }
        else {
            if (q === 0) {
                p ++
            }
            else {
                q = next[q - 1]
            }
        }
    }
    return q === nLen ? p - q : -1
};
```

### 7. 双指针

#### 7.1 快慢指针

解决数组或字符串中去除某一个值的问题

#### 7.2 滑动窗口

解决从数组中选出大小不一定且连续的子数组的问题
